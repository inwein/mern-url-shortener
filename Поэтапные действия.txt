1. Сначала бек енд потом фронт енд

2. Инициализируемся в пустой папке через npm init

3. Добавляем express & moongose (MongoDB)

4. Добавляем через -D nodemon & concurrently

5. Ставим конфиг

6. const app = express

7. в конфиге задаем порт и mongoUri (адрес БД)

8. делаем асинхрон функцию старта и сразу запускаем. В функции сначала подключаем БД, потом
стартуем сервер с прослушкой того что там происходит. 
Не забываем прописать catch с process.exit()

9. Подключаем роут через app.use('name', require(инструкция обработки роута))

10. Папку routes, где прописываем роуты

11. В роуте {Router} из express. router.post, router.get - обработчики запросов на роут
Не забываем module.exports = route

12. Создаем модели в models 
const {Schema, model} = require('mongoose')

13. описываем схему - const schema = new Schema ({
    email: {type: String, required: true, unique: true},
    password : {type: String, required: true},
    links: [{type: Types.ObjectId, ref: 'Link'}]
})

14. Експортируем через модуль, обернув в  model('User', schema)

15. Устанавливаем bcrypt в роут, для хеширования пароля с целью его защиты

16. Устанавливаем express-validator для валидирования полей почты и пароля. 
const {check, validationResult} = require('express-validator')

17. Прописываем как проверять через check('имя поля для проверки', 'сообщение которое вернется в случае ошибки').is..... - метод проверки

18. Вставляем проверку закинув наш req (Request) в validationResult(req). 

19. Пишем условия для возврата сообщений из проверки на фронт енд, если такие ошибки были обнаружены. Проверка должна происходить до основной логики авторизации. 

20. Описываем точно также все условия для логина, валидации и тп. 

21. Чтобы сверить захешированный пароль используем bcrypt.compare(), куда передаем пароль введенный и захешированный пароль через найденного юзера. 

22. Устанавливаем jsonwebtoken

23. Начинаем авторизацию с создания токена при помощи JWT

24. В конфиге прописываем Секретный ключ для jwt 

25. Используем секретный ключ в токене, задаем срок годности токена 

26. В завершение авторизации возвращаем токен и юзер айди. 

27. Создаем папку client через create-react-app, где будет лежать клиентская часть 

28. Добавляем в package.json client: "npm run start --prefix client"
Для создания команды запуска фронта

29. делаем scripts :
dev : concurrently \"npm run server\" \"npm run client\"
Для того чтобы по npm run dev запускался и сервер и клиент

30. Также важно устанавливать реакт через npm без yarn & yarn lock 
если получилось через ярн, нужно подчистить и через npm i переустановить node, git

-------- REACT

31. Делаем роуты в Реакте в отдельном файле routes.js 
A страницы закидываем в папку pages
<Router to="/" exact>
<AuthPage/>
</Router> 

32. Важно использовать в самом конце перед /Switch - <Redirect />, он блокирует от перехода на несуществующие страницы или недоступные 

33. Также важно оборачивать итоговые routes уже в App.js в BrowserRouter

34. Создаем свой хук useHttp где описываем свою логику запросов используя fetch

35. Импортируем хук в страницу с авторизацией, где декомпозируем его на те компоненты, которые
он выдает. 

36. Используем реквест указывая параметры регистрации 

37. Чтобы запросы на локальный сервер работали, указываем прокси локалхост 5000 в package json клиента
Это только для разработки 

38. У нас будут вылазить ошибки ,потому что реквест, которые прилетает на бекенд не в правильно формате.

39. Нужно в файле сервера app.js использовать вспомогательную конструкцию, чтобы привести его в порядок 

40. Далее в хуке useHttp нашем кастомном, мы в поле try описываем, что если у нас в боди есть что то, то мы Джейсон стрингифаем боди, и в хедерс ставим контент тайп application/json

41. Создаем хук для вывода сообщений с ошибками, на основе Материалайз ЦСС

42. Чтобы передать Колбек в списке зависимостей - нужно обернуть его в useCallback

43. Возникла ошибка с работой формы на логин и авторизацию, так как bcrypt не обернул в await 

44. Делаем отдельный хук для авторизации, где мы реализуем логику Логина с присваиванием в стейт токена и юзерАйди и логику Логаута. 

45. В Логине мы ставим токен и юзерайди в стейт местного хука и также помещаем эти же данные в локалсторедж используя JSON.stringify, для правильной передачи данных в локалстор

46. В Логауте мы чистим местные стейты и локалстор

47. Добавляем useEffect чтобы доставать из LocalStorage инфо и сразу логиниться, если она есть


48. Добавляем и декомпозируем то что возвращает вызов нашего хука useAuth в корневом файле App.js

49. Создаем в корне папку Context, где создадим контекст, который будет аналогом Редакса для всего нашего приложения

50. Создаем дефолтный авторизационный контекст через createContext({})

51. Оборачиваем всё приложение App в AuthContext, чтобы он передавался во все его части

52. <AuthContext.PROVIDER(!)></Auth.........>

53. !!token - приводит к boolean type

54. В контекст закидываем в value token , id, login, logout, и созданную const isAuthenticated

55. передаем значение isAuthenticated в routes, чтобы оно меняло роутинга в зависимости от того есть у нас токен или нет, что подразумевает авторизован пользоваттель или нет

56. На странице авторизации создаем константу auth = useContext(AuthContext), которая и получит весь заданный нами контекст

57. В loginHandlere вызываем метод Login auth.login(куда передаем зафетченный токен и юзер айди)

58. При логине нас сразу редиректит на страницы для пользователей

59. Создаем навигацию для авторизованых пользователей

60. Используем контекст, что взять оттуда функцию логаута, чтобы привязать ее на клик по пункту меню "Выйти"

61. Дальше, чтобы реализовать редирект при выходе, мы берем useHistory из react-router-dom

62.     const history = useHistory()
        history.push('/')

63. {isAuthenticated && <NavBar />} - если Авторизован - то показывать Navbar

64. Возвращаемся на Бекенд и делаем link.routes.js и модель Link.js

65. Описываем схему модели Link

66. В линк.роут подключаем Роутер из Экспресса, подключаем модель Линк, задаем шаблоны описания Пост запроса на /generate и получение списка ссылок и каждой ссылки отдельно

67. В app.js подключаем роут через app.use('адресс роута', 'путь к файлу где лежит описание работы роута') 

68. Прописываем получение всего списка и получение каждой отдельной ссылки. 

69. Чтобы все правильно работало нужно создать отдельный middleware, который будет обрабатывать поиск юзера по токену. Делаем это в отдельной папке в корне приложения. 

70. В middleware мы получаем токен из хедера запроса, где потом его превращаем в массив и дальше декодируем при помощи библиотеки jsonwebtoken и секретного ключа в конфиге. 

71. Результат декодировки запихиваем в реквест.user

72. вставляем middleware в описании запроса между роутом и коллбеком. 

73. В коллбеке описываем, что будем вытаскивать айди юзера из req.user.userId

74. Прописываем базовый урл в конфиге, чтобы при сокращении ссылки мы подставяли основу нашего урл

75. Импортируем конфиг , получаем из него урл в описании роута generate

76. Из req.body получаем from, чтобы понимать куда должна привести ссылка

77. Возвращаемся на фронт енд и делаем страницу Create, где задаем стилистику

78. Из инпута при переменах задаем локальный стейт. 

79. При нажатии на Ентер ставим обработчик, который делает пост запрос на api/links/generate
Он должен пулить туда введенную ссылку из локального стейта

80. Нужно также использовать контекст, что при обработке пост запроса передать четвертым параметром содержимое для Headers 

81. Используем хук useHistory, чтобы после создания ссылки происходил редирект

82. Добавляем Loader и стейт под него в хук авторизации, чтобы при обновлении страницы мы не слетали с той страницы, которая уже открыта у авторизованного пользователя, так как функция авто-авторизации асинхронна.

83. Дальше для страницы с инфой по каждой ссылке создаем макет

84. Подтягиваем из контекста Токен, задаем местный стейт, получаем линк айди из урл

85. Создаем метод getLink, который используем в useEffect при загрузке страницы

86. Выводим элемент ссылки если у нас закончилась загрузка и полученна ссылка в стейт

87. Создаем страницу со всеми ссылками в виде таблицы

88. Создали Компонент для каждой отдельной ссылки. 

89. Пофиксили баг из за которого не фетчилась инфа на страницу Линкс. Ошибка в Прокси с 3000 на 5000 локалхост. В конфиге в конец прокси нужно добавить '/'

90. Теперь добавляем функционал, чтобы при клике на ссылку можно было считать клики и был реальный переход на нужную страницу 

91. Для этого создаем еще один роут на бекенде. 

92. Подключаем его в app.js 

93. В роутере создаем гет запрос, который будет случаться при клике на ссылку, где идентификацию линка будем проводить по коду. 

94. линк = ожидаем поиск линка по коду

95. Если линк найден, то плюсуем клик в его свойство clicks

96. Потом ожидаем сохранение измененного линка

97. В качестве респонса отдаем редирект на link.from

98. В других случаях выдаем 400 ошибку с json "Ссылка не найдена"

